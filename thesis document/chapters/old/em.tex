% !TEX root =  ../thesis.tex

\section{Introduction}

The Em document is the one specifying the hierarchical structure of the GUI, listing all the UI components that will be present.
I also include its interactive and state properties and all the necessary information to connect to the Ex and Es files. More precisely, for each element contained in the Em file, we can specify:

\begin{itemize}
    \item (required) \textbf{type} of the element (EmFrame, EmButton, \ldots)
    \item \textbf{id} and \textbf{classes} for each element (used to connect with the Ex and Es files, see \ref{sec:selectors} for more details)
    \item enabled/disabled state for each available \textbf{event}
    \item \textbf{state variables} specific to the element (e.g.: text of a button)
\end{itemize}

Before proceeding any further, we will now introduce a syntax that will consistently be used to provide examples of Em code.

\section{Em syntax}

As explained in \ref{sec:design_syntax}, we use JSON to encode Em elements. Each element will be a JSON hash table. The element type is defined in the \textit{type} attribute. To specify the hierarchy, the \textit{children} attribute is used (an array of children, between square brackets). This is a very simple example of an Em document that displays two buttons:

\begin{verbatim}
    {type: EmFrame, id: myContainer, children: [
        {type: EmButton, id: okButton, text: "ok"},
        {type: EmButton, id: cancelButton, text: "cancel"}
    ]}
\end{verbatim}

\section{EmDocument}

Before proceeding in explaining in details each available Em element, we will introduce EmDocument. This serves as a container for all other elements, and defines the whole interface. Also, three additional functions are performed by the EmDocument:

\begin{itemize}
    \item contains links to Es and Ex files, which define layout and style for the EmDocument but are conceptually and physically separate files.
    \item provides the signature of the linked Es and Ex files.
    \item provides the signature of the content, generated by the server, used to verify the integrity of the EmDocument.
\end{itemize}

\section{Em elements}
\label{sec:em_elements}

Up to now we talked about the general structure and design of an Em, Ex and Es application, but to actually implement a working UI we need a few basic UI elements to interact with. We will now list all available Em components, this section will serve as a reference of all components, their properties and events. For each element we will specify:

\begin{description}
    \item [type] the type of the element
    \item [parent element] the element from which it inherits (in the Object Oriented sense of inheritance). This means that all events and properties are inherited.
    \item [frame-like] if the element is frame-like or not. Refer to chapter \ref{ex} for a definition of frame-like, since this is only relevant for layout purposes
    \item [properties] a list of properties, with their valid values, default value and read-only state.
    \item [events] a list of available events that the element can send to the remote server. For more details of events and user interaction, refer to chapter \ref{interaction}.
\end{description}

\subsection{EmFrame}
\label{sec:emframe}

\begin{verbatim}
parent element: none
frame-like: true
properties: none
events: none
\end{verbatim}

EmFrames are the main building block for laying out interfaces. They serve as generic rectangular containers, and all their children will be rendered inside their bounds. They do not have any particular property or event associated with them, and do not inherit from any other element. All their power comes from the layout and style properties that can be associated with them.

\subsection{EmSection}
\label{sec:emsection}

\begin{verbatim}
parent element: EmFrame
frame-like: true
properties: (see table)
events: none
\end{verbatim}

\begin{table}[ht]
\caption{EmSection properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
title & String & empty & NO \\
newScope & Boolean & False & NO \\
sectionNestingLevel & Integer & - & YES \\
sectionNumbering & Integer[] & - & YES \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
% \label{table:nonlin} % is used to refer this table in the text
\end{table}

Text documents have been historically divided in parts hierarchically, with these parts having names such as chapters, sections, paragraphs, etc\ldots
These structural dividers have a few things in common:
\begin{itemize}
    \item they have a title and a content
    \item they are nested in order (a subsection cannot be directly contained in a chapter, but only in a section). This implies that the type of divider can be inferred by the nesting level.
\end{itemize}

Considering these two factors, I will start defining a new Em element called \textbf{EmSection}. An EmSection has a title and a content. The type (chapter, section, document\ldots) is not specified explicitly but inferred based on the nesting level.

\begin{verbatim}
    {type: EmSection, title: "section title", children: [
        ...
    ]}
\end{verbatim}

This concept is similar to the one of frames, being a hierarchical representation of the UI. However, frames are meant to be used for layout and the frame hierarchy is not directly relevant for the user. The section hierarchy, on the contrary, is explicit and very semantic, and users can interact with it easily since they are used to its presence. Certain interactions will be natural, for example the ability to collapse/expand sections or the presence of a table of contents where each line is a link to the corresponding section.

We should think of sections as an additional hierarchy, specified inside the main Em hierarchy, that highlights the important semantic relations between groups of elements. Sections could be used to divide text in the usual way, or to divide GUI areas (menu, toolbars, content area\ldots), or more generally to do both. In fact, while we have been referring to sections as a way to organize and divide text, after some considerations we realize that there is no real problem in having sections work with other UI elements as well (such as frames, buttons etc\ldots).

However, while an EmFrame and an EmSection are conceptually different, the second is actually extending (with additional semantics and properties) the first one. An EmSection is actually a subclass of an EmFrame, and can be used for layout in the same way. Therefore we can replace a normal EmFrame with an EmSection to add semantics, and keep the same layout properties. Further explanations regarding the layout of EmFrame (and EmSection) will be given in chapter \ref{ex}.

Sections are an optional hierarchical organization of the UI (both interactive and text based), specified by the programmer but accessible and comprehensible by the end user. This is clearly different from frames, which are mainly devoted to layout organization, and the two structures can naturally coexist in the same document.

\subsection{Section scoping}

In complex documents, we can imagine a UI which uses sections to be organized (similar to a what a sitemap is) and at the same time uses sections in a text area to organize text. These two things are clearly in conflict, since we want the sections in the text area to be restricted to the text area itself. That is why we introduce the concept of section scoping, with the attribute \texttt{newScope}, which has the effect of resetting the nesting level for its children:

\begin{verbatim}
{type: EmSection, title: "content area", children: [ /* level 1 */
    {type: EmSection, title: "text area", newScope: true, children: [ /* level 2 */
        {type: EmSection, title: "chapter 1", children: [...]} /* level 1 */
        {type: EmSection, title: "chapter 2", children: [...]} /* level 1 */
    ]}
    {type: EmSection, title: "menu area", children: [ /* level 2 */
        ...
    ]}
]}

\end{verbatim}

Using section scoping, we can refer to the element nesting level as relative to its scope, which is the distance in terms of sections from the first EmSection ancestor having \texttt{newScope: true}. Section scoping will be useful mainly for two reasons: directly using the number representing the nesting level and applying layout and styles based on it.

\subsection{Section numbering}

It is often useful to auto generate text based on the section number. For example in \LaTeX  documents chapter are automatically numbered and the document structure is always consistent because it is computed and not entered manually.

To access a section number two properties are available over an EmSection element:
\begin{itemize}
    \item \texttt{sectionNumbering [array[int]]} returns an array of integers, using the normal numbering for sections, starting from nesting level 1 up to the current section. An example would be \texttt{[3,2,2]}, which would represent what is usually written as \texttt{3.2.2} next to the section title in \LaTeX documents.
    \item \texttt{sectionNestingLevel [int]} this is simply the length of the array above, and represents the section nesting level. The main purpose of this element is to allow easy styling of sections.
\end{itemize}

\subsection{Section headers}

Sections are, similarly to frames, invisible elements unless something is put inside them. Differently to sections in \LaTeX, in Em the title is not displayed directly (it can be used to generate a table of contents, or accessed from other elements\ldots). If we need to have a real section title (as we do when using sections in a traditional text environment) we can simply define it as its first child. Details on how this affects style definition will be provided in \ref{sec:styling_sections}.

\subsection{Advanced section behaviors}

As previously hinted, sections are more than just titles and headers. They can give structure to the whole interface, both text and UI, and provide a natural way for users to interact with this structure.

Two main advanced interactions are available: the table of contents and collapsing / expanding of sections.

The \textbf{table of contents} of an Em document can be generated by visiting its section hierarchy. It will then be presented in a consistent way in the client, for example a nested menu which gives a quick view of the document structure and provides links to the corresponding sections. This behavior is not optional and such menu (or similar view) should always be present in all applications that use sections, as to enforce their semantic value for the user.

The \textbf{collapsing and expanding} of sections will, on the contrary, be optional and configurable by the property \texttt{userCollapsible: true/false (defaults to false)} and controlled programmatically using the style property \texttt{sectionCollapsed: true/false} (more details in the style chapter at \ref{sec:styling_sections}). When a section is collapsed, all its children except the first one will be hidden. It is required to use the first child as section header for the collapsing to operate correctly.

\subsection{EmText}

\begin{verbatim}
parent element: none
frame-like: false
properties: (see table)
events: none
\end{verbatim}

\begin{table}[ht]
\caption{EmText properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
text & String & empty & NO \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}
% \label{table:nonlin} % is used to refer this table in the text
\end{table}

EmText is a generic text container which contains a single string. it is useful to associate styles to strings, and behaves similarly to the HTML \texttt{span} element, but restricted to containing only strings. It is not visually rendered unless property value of certain elements (such as EmLabel and EmParagraph), and it is not a frame-like component.

\subsection{EmLabel}

\begin{verbatim}
parent element: none
frame-like: true
properties: (see table)
events: none
\end{verbatim}

\begin{table}[ht]
\caption{EmLabel properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
text & String & empty & NO \\
textElements & EmText[] & null & NO \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

Displays a single line of text, without wrapping. It behaves as an EmText, meaning it has a text property, but can also contain other EmText elements to provide inline formatting. The final output will be a concatenation of the string contained in \texttt{text} and the contained EmText elements. It is a frame-like component.

\subsection{EmParagraph}

\begin{verbatim}
parent element: EmLabel
frame-like: true
properties: none
events: none
\end{verbatim}

Similar to an EmLabel but with one major difference: text can wrap to new lines. Also, EmParagraph support additional style attributes (line spacing etc..) as we will see in chapter \ref{es}. Since it inherits from EmLabel, we have access to the text and textElements properties (as defined in the EmLabel section).

\subsection{EmButton}

\begin{verbatim}
parent element: EmLabel
frame-like: true
properties: (see table)
events: selectionStart, selectionEnd, secondarySelectionStart,
        secondarySelectionEnd
\end{verbatim}

\begin{table}[ht]
\caption{EmButton properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
enabled & Boolean & True & NO \\
interactionState & NORMAL, PRESSED & NORMAL & YES \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

An EmLabel that additionally provides and manages click events. Clearly it is a frame like components, since it extends a frame like component (EmLabel). The user can interact with it in various ways. On a computer, for example, the user can click, double click and right click. On a touch device, she can touch and long touch. In general, all these actions have something in common: they have a begin phase (click down or start touching) and then an end phase (click up or finish touching). This component behavior will depend on the device/client it is rendered by, but for the server application this won't make any difference because the server side events are predefined. We have 4 events available, 2 different interactions (primary, secondary) and two events for each one (start, end). it is the client responsibility to map these events to some kind of user interaction specific to that device.

The button can be enabled or disabled, and its interaction state can be accessed through the interactionState property (this is mainly useful for styling the button differently based on its state). The value of interactionState is PRESSED only after a user has started an interaction with the button, and she hasn't finished it yet (mouse down, touching..).

\subsection{EmLink}

\begin{verbatim}
parent element: EmLabel
frame-like: true
properties: (see table)
events: none
\end{verbatim}

\begin{table}[ht]
\caption{EmLink properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
enabled & Boolean & True & NO \\
linkTo & String &  & NO \\
interactionState & NORMAL, PRESSED & NORMAL & YES \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

This component defines a link to another section in the document. Pressing it will make the interface go to the
section having the id specified in the linkTo property, called the target section. This means that the target
section, and all its ancestor sections, will be expanded. Also, if the parent section to the target section
has the style property oneChildExpanded set to true, we can simulate a tab panel behavior (see Chapter on Es for more details).

It is a frame like components, since it extends a frame like component (EmLabel). The user can interact with it in various ways, like with the EmButton. The main difference from an EmButton is that EmLink does not have events, and therefore does not generate
remote commands.

The button can be enabled or disabled, and its interaction state can be accessed through the interactionState property in
the same way we can do with EmButton.

\subsection{EmSelectableButton}
\label{sec:emselectablebutton}

\begin{verbatim}
parent element: EmButton
frame-like: true
properties: (see table)
events: selectedStateChanged(selectedState)
\end{verbatim}

\begin{table}[ht]
\caption{EmSelectableButton properties}
\centering
\begin{tabular}{l p{5cm} l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
selectedState & SELECTED, DESELECTED & DESELECTED & YES \\
nextSelectable & id: EmSelectableButton & null & NO \\
groupSelection & ONE, EXCLUSIVE, MULTIPLE & EXCLUSIVE & NO \\
stateChangingInteraction & SELECTION\_START, SELECTION\_END,
SECONDARY\_SELECTION\_START, SECONDARY\_SELECTION\_END & SELECTION\_END & NO \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

Extends EmButton adding a new state property, selectedState. The values it can take are the usual \texttt{SELECTED, DESELECTED}. The state changes when an interaction of type stateChangingInteraction is performed (defaults to SELECTION\_END, which on a normal computer would be a click up). After the state is changed, an event selectedStateChanged is raised, which is dispatched along with the new selectedState.

An EmSelectableButton can be used for example as a checkbox, provided two different styles are associated with its two different states.

EmSelectableButtons can be chained, forming and ordered list, using the nextSelectable property (which can contain the id of another EmSelectableButton). In a chain, the selection behavior is different. It is specified in the first element of the chain with the \texttt{groupSelection} property, and can be one of the following:

\begin{description}
    \item[EXCLUSIVE] only one element in the chain can be selected, or none.
    \item[ONE] same as EXCLUSIVE, but exactly one element has to be selected. If none is selected, the first one in the chain is automatically selected and the \texttt{selectedStateChanged} event is raised.
    \item[MULTIPLE] zero or more elements can be selected. The effect of the \texttt{stateChangingInteraction} depends of the currently pressed modifier key:
    \begin{description}
        \item[mo modifier] the element is selected, all others are deselected
        \item[SHIFT key] all elements between the last selected one and the current one are selected
        \item[CTRL key] selection for the current element is toggled
    \end{description}
\end{description}

\subsection{EmInput}

\begin{verbatim}
parent element: EmLabel
frame-like: true
properties: (see table)
events: inputChanged
\end{verbatim}

\begin{table}[ht]
\caption{EmInput properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
enabled & Boolean & True & NO \\
validation & String & .* & NO \\
validationState & PRISTINE, ERROR, VALID & PRISTINE & YES \\
interactionState & NORMAL, FOCUSED & NORMAL & YES \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

This component defines a textbox to be used for user input. it is a subclass of EmLabel, where the
text property can be directly changed by the user by typing into the text box. This element behaves
as you would expect a normal form text field to behave.

It is a frame like components, since it extends a frame like component (EmLabel).
The EmInput can be enabled or disabled, and its interaction state can be accessed through the interactionState property in
the same way we can do with EmButton, but in this case it can be NORMAL or FOCUSED, when the user is
writing in the EmInput text box.

The validation property specifies the validation pattern, as a regular expression, that should be respected
by the text property. If the text does not match the validation pattern, the validationState property
is set to ERROR. This can be used to style the EmInput (for example with a red border) when the text is
not valid. If the text is invalid, but the user hasn't typed yet (usually when the text is still empty),
the validationState property is set to PRISTINE.

It has one event, inputChanged, which is raised every time the user changes the value of the text
property (by typing in something). The event raised will contain, alongside the usual EmEvent data, a
text property with the value of the EmInput text property (more details on events in the Interaction chapter).

\subsection{EmMenu}
\label{sec:emmenu}

\begin{verbatim}
parent element: none
frame-like: false
properties: none
events: none
\end{verbatim}

\begin{table}[ht]
\caption{EmMenu properties}
\centering
\begin{tabular}{l l l l}
\hline\hline
name & type & default & read only \\ [0.5ex]
%heading
\hline % inserts single horizontal line
title & String & empty & NO \\ [1ex] % [1ex] adds vertical space
\hline %inserts single line
\end{tabular}

\end{table}

This component is a way to create menus in Em. Menus are a hierarchical collection of buttons. They could
theoretically be created only using EmButton and some layout/style properties. However, since menus
are ubiquitous and very useful components, the EmMenu element provides a simple way to define them.

Each menu is associated with an section. There can be only one menu element for each section, and it
should be its child. The menu should contain buttons that perform commands related to that section.

Menus can be nested, to define the usual hierarchy we can find in menu bars. To specify the title of
each submenu, and of the main menu, we use the title property. The leaves of the menu hierarchy are EmButton
elements. They behave as usual buttons, with the only difference of being shown inside the menu structure.

Menus are all shown in a general menu bar (similar, for example, to the typical OSX menu bar).
However, since we have (up to) one menu per section, we must show multiple menus in the menu bar. Only the
menus corresponding to sections that are expanded will be shown, and they will be displayed in order,
visiting the section tree breadth first (see the examples Chapter to better understand how menus can be used).
